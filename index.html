<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <title>Adventure with Koko</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* CRITICAL FIX: Disables default touch actions (scrolling/panning) on the whole body */
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background-image: url('back.png');
            background-size: cover;
            background-position: center;
        }
        /* --- MOBILE CONTROLS STYLING --- */
        .controls-overlay {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            pointer-events: none; /* Let touches pass through empty spaces */
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
        }
        /* Only show controls on touch devices or small screens */
        @media (min-width: 1024px) {
            .controls-overlay { display: none; }
        }
        @media (max-width: 1023px) {
            .controls-overlay {
                bottom: 10px;
                height: 100px;
                padding: 0 10px;
            }
            .d-pad, .action-btn {
                gap: 10px;
            }
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 18px;
            }
        }
        .d-pad, .action-btn {
            pointer-events: auto; /* Re-enable pointer events for buttons */
            display: flex;
            gap: 20px;
        }
        .control-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: none;
            backdrop-filter: blur(4px);
        }
        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }
        #rotateOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            text-align: center;
            z-index: 200;
            display: none;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="controls-overlay">
    <div class="d-pad">
        <div class="control-btn" id="btn-left">◀</div>
        <div class="control-btn" id="btn-right">▶</div>
    </div>
    <div class="action-btn">
        <div class="control-btn" id="btn-jump" style="background: rgba(255, 200, 0, 0.3);">▲</div>
    </div>
</div>
<div id="rotateOverlay">
    <div>Please rotate your device to landscape mode to play.</div>
</div>
<script>
// ===========================
// Game Setup & Globals
// ===========================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const winnerImage = new Image();
winnerImage.src = "1.png";
// --- DYNAMIC RESOLUTION SETUP ---
let GAME_WIDTH = window.innerWidth;
let GAME_HEIGHT = window.innerHeight;
let isLandscape = false;
function resizeCanvas() {
    GAME_WIDTH = window.innerWidth;
    GAME_HEIGHT = window.innerHeight;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
}
function checkOrientation() {
    isLandscape = window.innerWidth > window.innerHeight;
    if (isLandscape) {
        document.getElementById('rotateOverlay').style.display = 'none';
        canvas.style.display = 'block';
    } else {
        document.getElementById('rotateOverlay').style.display = 'flex';
        canvas.style.display = 'none';
    }
}
// Initial setup
resizeCanvas();
checkOrientation();
window.addEventListener('resize', () => {
    resizeCanvas();
    checkOrientation();
});
const isMobile = window.innerWidth < 1024;
const scaleFactor = isMobile ? 0.4 : 1;
const speedMultiplier = isMobile ? 1.5 : 1;
let controlHeight = isMobile ? 90 : 40;
const STATE = {
    START: 0,
    PLAYING: 1,
    GAMEOVER: 2,
    WIN: 3
};
let currentState = STATE.START;
const GRAVITY = 0.5 * scaleFactor;
const FRICTION = 0.8;
let score = 0;
let cameraX = 0;
// Centralized Input State
const keys = {
    right: false,
    left: false,
    up: false,
    space: false
};
// ===========================
// INPUT HANDLING (DESKTOP + MOBILE)
// ===========================
// 1. Desktop Keyboard Support
document.addEventListener('keydown', (e) => {
    // Prevent scrolling with arrow keys
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    // Handle Game State Transitions via Enter
    if ((currentState === STATE.GAMEOVER || currentState === STATE.WIN) && e.code === 'Enter') {
        resetGame();
    }
    if (currentState === STATE.START && e.code === 'Enter') {
        currentState = STATE.PLAYING;
    }
});
document.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'Space') keys.space = false;
});
// 2. Mobile Touch Support
// We attach listeners to the HTML elements we created in the body
function attachTouch(elementId, key) {
    const el = document.getElementById(elementId);
    if (!el) return;
    // Touch Start -> Key Down
    el.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Stop mouse emulation
        keys[key] = true;
       
        // Handle Start/Restart Logic on Mobile via Jump Button
        if (key === 'up') {
            if (currentState === STATE.START) currentState = STATE.PLAYING;
            if (currentState === STATE.GAMEOVER || currentState === STATE.WIN) resetGame();
        }
    }, { passive: false });
    // Touch End -> Key Up
    el.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys[key] = false;
    }, { passive: false });
}
attachTouch('btn-left', 'left');
attachTouch('btn-right', 'right');
attachTouch('btn-jump', 'up');
// ===========================
// LOAD IMAGES
// ===========================
const playerLeftImg = new Image();
playerLeftImg.src = "left.png";
const playerRightImg = new Image();
playerRightImg.src = "right.png";
const goalImage = new Image();
goalImage.src = "Shri-Ajab-3D-Jaipuri-Mixture.png";
const enemyImageUrls = ["2.png", "3.png", "4.png", "5.png"];
const enemyImages = enemyImageUrls.map(url => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = url;
    return img;
});
// ===========================
// Game Classes
// ===========================
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 63 * scaleFactor;
        this.height = 112 * scaleFactor;
        this.velX = 0;
        this.velY = 0;
        this.maxSpeed = 8 * scaleFactor * speedMultiplier;      
        this.acceleration = 1.0 * scaleFactor * speedMultiplier;
        this.jumpStrength = -13 * scaleFactor;
        this.grounded = false;
        this.facingRight = true;
    }
    update() {
        if (keys.right) {
            if (this.velX < this.maxSpeed) this.velX += this.acceleration;
            this.facingRight = true;
        }
        else if (keys.left) {
            if (this.velX > -this.maxSpeed) this.velX -= this.acceleration;
            this.facingRight = false;
        }
        this.velX *= FRICTION;
        if (Math.abs(this.velX) < 0.1) this.velX = 0;
        if (keys.up && this.grounded) {
            this.velY = this.jumpStrength;
            this.grounded = false;
        }
        this.velY += GRAVITY;
        this.x += this.velX;
        this.y += this.velY;
        if (this.y > GAME_HEIGHT + 100 * scaleFactor) {
            currentState = STATE.GAMEOVER;
        }
    }
    draw(cameraOffset) {
        const drawX = this.x - cameraOffset;
        let imgToDraw = this.facingRight ? playerRightImg : playerLeftImg;
       
        let bob = 0;
        if (Math.abs(this.velX) > 0.5 && this.grounded) {
             bob = Math.sin(Date.now() / 100) * 3 * scaleFactor;
        }
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(drawX + this.width/2, this.y + this.height - 2 * scaleFactor, 15 * scaleFactor, 5 * scaleFactor, 0, 0, Math.PI*2);
        ctx.fill();
        if (imgToDraw.complete && imgToDraw.naturalHeight !== 0) {
            ctx.drawImage(imgToDraw, drawX, this.y + bob, this.width, this.height);
        } else {
            ctx.fillStyle = "red";
            ctx.fillRect(drawX, this.y, this.width, this.height);
        }
    }
}
class Platform {
    constructor(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height;
    }
    draw(cameraOffset) {
        ctx.save();
        ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
        ctx.shadowBlur = 10 * scaleFactor;
        ctx.shadowOffsetX = 6 * scaleFactor;
        ctx.shadowOffsetY = 6 * scaleFactor;
        ctx.fillStyle = "#5086b4";
        ctx.fillRect(this.x - cameraOffset, this.y, this.width, this.height);
        ctx.restore();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2 * scaleFactor;
        ctx.beginPath();
        ctx.moveTo(this.x - cameraOffset, this.y);
        ctx.lineTo(this.x - cameraOffset + this.width, this.y);
        ctx.stroke();
       
        for(let i = this.x; i < this.x + this.width; i+=40 * scaleFactor) {
             ctx.beginPath();
             ctx.moveTo(i - cameraOffset, this.y);
             ctx.lineTo(i - cameraOffset, this.y + this.height);
             ctx.stroke();
        }
    }
}
class Enemy {
    constructor(x, y, range) {
        this.x = x; this.y = y;
        this.width = 70 * scaleFactor; this.height = 70 * scaleFactor;
        this.startX = x; this.range = range;
        this.speed = 2 * scaleFactor * speedMultiplier; this.direction = 1;
        this.markedForDeletion = false;
        this.image = enemyImages[Math.floor(Math.random() * enemyImages.length)];
    }
    update() {
        this.x += this.speed * this.direction;
        if (this.x > this.startX + this.range || this.x < this.startX) {
            this.direction *= -1;
        }
    }
    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        if (this.image.complete && this.image.naturalHeight !== 0) {
            ctx.drawImage(this.image, drawX, this.y, this.width, this.height);
        } else {
            ctx.fillStyle = Math.random() > 0.5 ? "#E91E63" : "#FF5722";
            ctx.fillRect(drawX, this.y, this.width, this.height);
            ctx.fillStyle = "#FFF";
            ctx.font = `bold ${10 * scaleFactor}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText("BRAND", drawX + this.width/2, this.y + this.height/2);
            ctx.textAlign = "left";
        }
    }
}
class ShriAjabGoal {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.width = 60 * scaleFactor; this.height = 40 * scaleFactor;
    }
   
    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        if (goalImage.complete && goalImage.naturalHeight !== 0) {
            ctx.drawImage(goalImage, drawX, this.y, this.width, this.height);
        } else {
            ctx.fillStyle = "transparent";
            ctx.fillRect(drawX, this.y, this.width, this.height);
        }
       
        let logoTopY = this.y - 40 * scaleFactor;
        if (winnerImage.complete && winnerImage.naturalHeight !== 0) {
            ctx.drawImage(winnerImage, drawX - 10 * scaleFactor, logoTopY, 80 * scaleFactor, 80 * scaleFactor);
        }
        ctx.save();
        ctx.fillStyle = "#FFD700";
        ctx.font = `bold ${16 * scaleFactor}px 'Press Start 2P'`;
        ctx.textAlign = "center";
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 4;
        ctx.fillText("WINNER", drawX + this.width / 2, logoTopY - 15 * scaleFactor);
        ctx.restore();
    }
}
class Decoration {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
    }
    draw(cameraOffset) {
        ctx.fillStyle = "#A1887F";
        if(this.type === 'arch') {
             ctx.beginPath();
             ctx.arc(this.x - cameraOffset, this.y, 40 * scaleFactor, Math.PI, 0);
             ctx.fill();
             ctx.fillRect(this.x - 40 * scaleFactor - cameraOffset, this.y, 10 * scaleFactor, 60 * scaleFactor);
             ctx.fillRect(this.x + 30 * scaleFactor - cameraOffset, this.y, 10 * scaleFactor, 60 * scaleFactor);
        }
    }
}
// ===========================
// Game Logic
// ===========================
let player;
let platforms = [];
let enemies = [];
let decorations = [];
let goal;
function initGame() {
    score = 0;
    cameraX = 0;
    let groundY = GAME_HEIGHT - controlHeight;
   
    player = new Player(100 * scaleFactor, groundY - 150 * scaleFactor);
   
    platforms = [
        new Platform(0, groundY, 1000 * scaleFactor, 40 * scaleFactor),
        new Platform(1100 * scaleFactor, groundY, 800 * scaleFactor, 40 * scaleFactor),
        new Platform(2000 * scaleFactor, groundY, 1000 * scaleFactor, 40 * scaleFactor),
       
        new Platform(300 * scaleFactor, groundY - 150 * scaleFactor, 150 * scaleFactor, 30 * scaleFactor),
        new Platform(700 * scaleFactor, groundY - 80 * scaleFactor, 150 * scaleFactor, 30 * scaleFactor),
       
        new Platform(500 * scaleFactor, groundY - 160 * scaleFactor, 150 * scaleFactor, 30 * scaleFactor),
        new Platform(1200 * scaleFactor, groundY - 110 * scaleFactor, 200 * scaleFactor, 30 * scaleFactor),
        new Platform(1800 * scaleFactor, groundY - 110 * scaleFactor, 150 * scaleFactor, 30 * scaleFactor),
       
        new Platform(1500 * scaleFactor, groundY - 210 * scaleFactor, 200 * scaleFactor, 30 * scaleFactor),
        new Platform(2200 * scaleFactor, groundY - 110 * scaleFactor, 100 * scaleFactor, 30 * scaleFactor),
        new Platform(2400 * scaleFactor, groundY - 210 * scaleFactor, 100 * scaleFactor, 30 * scaleFactor),
        new Platform(2600 * scaleFactor, groundY - 310 * scaleFactor, 300 * scaleFactor, 40 * scaleFactor)
    ];
    enemies = [
        new Enemy(400 * scaleFactor, groundY - 70 * scaleFactor, 200 * scaleFactor),
        new Enemy(1200 * scaleFactor, groundY - 180 * scaleFactor, 150 * scaleFactor),
        new Enemy(1600 * scaleFactor, groundY - 280 * scaleFactor, 100 * scaleFactor),
        new Enemy(2100 * scaleFactor, groundY - 70 * scaleFactor, 300 * scaleFactor)
    ];
   
    goal = new ShriAjabGoal(2750 * scaleFactor, groundY - 350 * scaleFactor);
}
function resetGame() {
    currentState = STATE.START;
    initGame();
}
function checkCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}
function update() {
    if (!isLandscape) return;
    if (currentState !== STATE.PLAYING) return;
    player.update();
   
    player.grounded = false;
    for (const plat of platforms) {
        if (checkCollision(player, plat)) {
            if (player.velY > 0 && player.y + player.height - player.velY <= plat.y) {
                player.grounded = true;
                player.velY = 0;
                player.y = plat.y - player.height;
            }
            else if (player.velY < 0 && player.y - player.velY >= plat.y + plat.height) {
                 player.velY = 0;
                 player.y = plat.y + plat.height;
            }
        }
    }
   
    for (const plat of platforms) {
        if (checkCollision(player, plat)) {
            if(player.velX > 0 && player.x + player.width - player.velX <= plat.x) {
                 player.x = plat.x - player.width;
                 player.velX = 0;
            }
            else if(player.velX < 0 && player.x - player.velX >= plat.x + plat.width) {
                 player.x = plat.x + plat.width;
                 player.velX = 0;
            }
        }
     }
    enemies.forEach(e => e.update());
    enemies.forEach(enemy => {
        if (!enemy.markedForDeletion && checkCollision(player, enemy)) {
            enemy.markedForDeletion = true;
            score += 100;
        }
    });
   
    if(checkCollision(player, goal)) {
        currentState = STATE.WIN;
        score += 1000;
    }
    enemies = enemies.filter(e => !e.markedForDeletion);
    let targetCameraX = player.x - GAME_WIDTH / 2 + player.width / 2;
    if(targetCameraX < 0) targetCameraX = 0;
    cameraX += (targetCameraX - cameraX) * 0.1;
}
function drawUI() {
    ctx.fillStyle = "#000";
    ctx.font = `${20 * scaleFactor}px Arial`;
    ctx.fillText("Score: " + score, 20, 30);
}
function drawOverlay(title, subtitle) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
   
    ctx.fillStyle = "#FFC107";
    ctx.textAlign = "center";
    ctx.font = `bold ${40 * scaleFactor}px Arial`;
    ctx.fillText(title, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20 * scaleFactor);
   
    ctx.fillStyle = "#FFF";
    ctx.font = `${20 * scaleFactor}px Arial`;
    // Modified subtitle to include mobile instruction
    ctx.fillText(subtitle, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30 * scaleFactor);
    ctx.textAlign = "left";
}
function draw() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    if (currentState === STATE.START) {
        drawOverlay("ADVENTURE WITH KOKO", "Press Enter or Tap Jump to Start");
        return;
    }
    decorations.forEach(d => d.draw(cameraX));
    platforms.forEach(p => p.draw(cameraX));
    goal.draw(cameraX);
    enemies.forEach(e => e.draw(cameraX));
    player.draw(cameraX);
    drawUI();
    if (currentState === STATE.GAMEOVER) {
        drawOverlay("GAME OVER", "Tap Jump to Restart");
    } else if (currentState === STATE.WIN) {
        drawOverlay("YOU WIN", "Final Score: " + score + " - Tap Jump to Restart");
    }
}
initGame();
function gameLoop(timestamp) {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
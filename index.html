<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <title>Adventure with Koko - Mobile Optimized</title>
    <style>
        :root {
            --control-size: 80px;
            --control-margin: 20px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated; /* Sharpens sprites */
            background-image: url('back.png'); 
            background-size: cover;
            background-position: center;
        }

        /* --- ORIENTATION LOCK OVERLAY --- */
        #orientation-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a;
            color: white;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #orientation-overlay h1 { font-size: 2rem; margin-bottom: 20px; }
        #orientation-overlay p { font-size: 1.2rem; color: #ccc; }
        #rotate-icon { font-size: 4rem; margin-bottom: 20px; animation: rotate 2s infinite; }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }

        /* Logic: Show overlay in Portrait */
        @media screen and (orientation: portrait) {
            #orientation-overlay { display: flex; }
            #gameCanvas, .controls-overlay { display: none !important; }
        }

        /* --- MOBILE CONTROLS --- */
        .controls-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Hide controls on desktop */
        @media (min-width: 1024px) {
            .controls-overlay { display: none; }
        }

        .control-group {
            position: absolute;
            bottom: var(--control-margin);
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        .left-controls { left: var(--control-margin); }
        .right-controls { right: var(--control-margin); }

        .control-btn {
            width: var(--control-size);
            height: var(--control-size);
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.1s;
        }

        .control-btn:active, .control-btn.active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        #btn-jump { background: rgba(255, 200, 0, 0.25); border-color: rgba(255, 200, 0, 0.5); }
        #btn-jump:active, #btn-jump.active { background: rgba(255, 200, 0, 0.5); }

    </style>
</head>
<body>

<div id="orientation-overlay">
    <div id="rotate-icon">ðŸ“±</div>
    <h1>Rotate Device</h1>
    <p>This game requires Landscape mode.</p>
</div>

<canvas id="gameCanvas"></canvas>

<div class="controls-overlay">
    <div class="control-group left-controls">
        <div class="control-btn" id="btn-left">â—€</div>
        <div class="control-btn" id="btn-right">â–¶</div>
    </div>
    <div class="control-group right-controls">
        <div class="control-btn" id="btn-jump">â–²</div>
    </div>
</div>

<script>
// ===========================
// CORE ARCHITECTURE
// ===========================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimization: Disable alpha channel if not needed for canvas background

const assets = {
    winner: new Image(),
    playerLeft: new Image(),
    playerRight: new Image(),
    goal: new Image(),
    enemies: []
};

// PRESERVED ASSET PATHS
assets.winner.src = "1.png";
assets.playerLeft.src = "left.png";
assets.playerRight.src = "right.png";
assets.goal.src = "Shri-Ajab-3D-Jaipuri-Mixture.png";

["2.png", "3.png", "4.png", "5.png"].forEach(url => {
    const img = new Image();
    img.src = url;
    assets.enemies.push(img);
});

// Dynamic Resolution
let GAME_WIDTH = window.innerWidth;
let GAME_HEIGHT = window.innerHeight;

function resizeCanvas() {
    GAME_WIDTH = window.innerWidth;
    GAME_HEIGHT = window.innerHeight;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    // Note: If resize happens during gameplay, this might shift platforms relative to player.
    // In a real engine, we would scale the world, not just the canvas.
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ===========================
// INPUT SYSTEM
// ===========================
const keys = { right: false, left: false, up: false };

// Desktop
document.addEventListener('keydown', (e) => {
    // Prevent default scrolling for game keys
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') keys.up = true;
    
    handleStateInput(e.code);
});

document.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') keys.up = false;
});

// Mobile Touch (Multi-touch support)
function setupTouch(id, key) {
    const el = document.getElementById(id);
    if (!el) return;

    const handleStart = (e) => {
        e.preventDefault(); 
        keys[key] = true;
        el.classList.add('active'); // Visual feedback
        if (key === 'up') handleStateInput('Space');
    };

    const handleEnd = (e) => {
        e.preventDefault();
        keys[key] = false;
        el.classList.remove('active');
    };

    el.addEventListener('touchstart', handleStart, { passive: false });
    el.addEventListener('touchend', handleEnd, { passive: false });
    // Handle finger sliding off button
    el.addEventListener('touchcancel', handleEnd, { passive: false });
}

setupTouch('btn-left', 'left');
setupTouch('btn-right', 'right');
setupTouch('btn-jump', 'up');

function handleStateInput(code) {
    if (currentState === STATE.START && (code === 'Enter' || code === 'Space')) {
        currentState = STATE.PLAYING;
    }
    else if ((currentState === STATE.GAMEOVER || currentState === STATE.WIN) && (code === 'Enter' || code === 'Space')) {
        resetGame();
    }
}

// ===========================
// GAME LOGIC
// ===========================
const STATE = { START: 0, PLAYING: 1, GAMEOVER: 2, WIN: 3 };
let currentState = STATE.START;

// Physics Constants
const GRAVITY = 0.5;
const FRICTION = 0.8; 

// Camera State
let camera = { x: 0, y: 0 };
let score = 0;

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 63;
        this.height = 112;
        this.velX = 0;
        this.velY = 0;
        this.maxSpeed = 8;        
        this.acceleration = 1.0; 
        this.jumpStrength = -13;
        this.grounded = false;
        this.facingRight = true;
    }

    update() {
        // Horizontal Movement
        if (keys.right) {
            if (this.velX < this.maxSpeed) this.velX += this.acceleration;
            this.facingRight = true;
        } else if (keys.left) {
            if (this.velX > -this.maxSpeed) this.velX -= this.acceleration;
            this.facingRight = false;
        }

        this.velX *= FRICTION;
        if (Math.abs(this.velX) < 0.1) this.velX = 0;

        // Jumping
        if (keys.up && this.grounded) {
            this.velY = this.jumpStrength;
            this.grounded = false;
        }

        // Apply Physics
        this.velY += GRAVITY;
        this.x += this.velX;
        this.y += this.velY;

        // Death Floor
        if (this.y > GAME_HEIGHT + 300) { // Increased buffer for vertical scrolling
            currentState = STATE.GAMEOVER;
        }
    }

    draw(camX, camY) {
        const drawX = this.x - camX;
        const drawY = this.y - camY;
        
        let imgToDraw = this.facingRight ? assets.playerRight : assets.playerLeft;
        
        // Idle Bobbing Animation
        let bob = 0;
        if (Math.abs(this.velX) > 0.5 && this.grounded) {
             bob = Math.sin(Date.now() / 100) * 3;
        }

        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(drawX + this.width/2, drawY + this.height - 2, 15, 5, 0, 0, Math.PI*2);
        ctx.fill();

        if (imgToDraw.complete && imgToDraw.naturalHeight !== 0) {
            ctx.drawImage(imgToDraw, drawX, drawY + bob, this.width, this.height);
        } else {
            // Fallback
            ctx.fillStyle = "red";
            ctx.fillRect(drawX, drawY, this.width, this.height);
        }
    }
}

class Platform {
    constructor(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height;
    }

    draw(camX, camY) {
        const drawX = this.x - camX;
        const drawY = this.y - camY;

        // Optimization: Don't draw off-screen platforms
        if (drawX + this.width < 0 || drawX > GAME_WIDTH || drawY + this.height < 0 || drawY > GAME_HEIGHT) return;

        ctx.save(); 
        ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 6;
        ctx.shadowOffsetY = 6;
        ctx.fillStyle = "#5086b4";
        ctx.fillRect(drawX, drawY, this.width, this.height);
        ctx.restore(); 

        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(drawX, drawY);
        ctx.lineTo(drawX + this.width, drawY);
        ctx.stroke();
        
        // Texture detail
        ctx.beginPath();
        for(let i = this.x; i < this.x + this.width; i+=40) {
             let lineX = i - camX;
             ctx.moveTo(lineX, drawY);
             ctx.lineTo(lineX, drawY + this.height);
        }
        ctx.stroke();
    }
}

class Enemy {
    constructor(x, y, range) {
        this.x = x; this.y = y;
        this.width = 70; this.height = 70;
        this.startX = x; this.range = range;
        this.speed = 2; this.direction = 1;
        this.markedForDeletion = false;
        this.image = assets.enemies[Math.floor(Math.random() * assets.enemies.length)];
    }

    update() {
        this.x += this.speed * this.direction;
        if (this.x > this.startX + this.range || this.x < this.startX) {
            this.direction *= -1;
        }
    }

    draw(camX, camY) {
        let drawX = this.x - camX;
        let drawY = this.y - camY;

        if (this.image.complete && this.image.naturalHeight !== 0) {
            ctx.drawImage(this.image, drawX, drawY, this.width, this.height);
        } else {
            ctx.fillStyle = "#E91E63";
            ctx.fillRect(drawX, drawY, this.width, this.height);
        }
    }
}

class Goal {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.width = 60; this.height = 40;
    }
    
    draw(camX, camY) {
        let drawX = this.x - camX;
        let drawY = this.y - camY;

        if (assets.goal.complete && assets.goal.naturalHeight !== 0) {
            ctx.drawImage(assets.goal, drawX, drawY, this.width, this.height);
        } else {
            ctx.fillStyle = "gold";
            ctx.fillRect(drawX, drawY, this.width, this.height);
        }
        
        let logoTopY = drawY - 40;
        if (assets.winner.complete && assets.winner.naturalHeight !== 0) {
            ctx.drawImage(assets.winner, drawX - 10, logoTopY, 80, 80);
        }

        ctx.save(); 
        ctx.fillStyle = "#FFD700";
        ctx.font = "bold 16px 'Press Start 2P', cursive";
        ctx.textAlign = "center";
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 4;
        ctx.fillText("WINNER", drawX + this.width / 2, logoTopY - 15);
        ctx.restore();
    }
}

// ===========================
// MAIN LOOP & ENTITIES
// ===========================
let player;
let platforms = [];
let enemies = [];
let goal;

function initGame() {
    score = 0;
    camera = { x: 0, y: 0 };
    
    // Level generation baseline
    // We use a fixed reference so rotation doesn't break the level relative positions
    let groundY = GAME_HEIGHT - 40; 
    
    player = new Player(100, groundY - 150);
    
    platforms = [
        new Platform(0, groundY, 1000, 40),
        new Platform(1100, groundY, 800, 40),
        new Platform(2000, groundY, 1000, 40),
        
        new Platform(300, groundY - 150, 150, 30),
        new Platform(700, groundY - 80, 150, 30),
        
        new Platform(500, groundY - 160, 150, 30),
        new Platform(1200, groundY - 110, 200, 30),
        new Platform(1800, groundY - 110, 150, 30),
        
        new Platform(1500, groundY - 210, 200, 30),
        new Platform(2200, groundY - 110, 100, 30),
        new Platform(2400, groundY - 210, 100, 30),
        new Platform(2600, groundY - 310, 300, 40)
    ];

    enemies = [
        new Enemy(400, groundY - 70, 200),
        new Enemy(1200, groundY - 180, 150),
        new Enemy(1600, groundY - 280, 100),
        new Enemy(2100, groundY - 70, 300)
    ];
    
    goal = new Goal(2750, groundY - 350);
}

function checkCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function update() {
    if (currentState !== STATE.PLAYING) return;

    player.update();
    
    // Platform Collisions
    player.grounded = false;
    for (const plat of platforms) {
        if (checkCollision(player, plat)) {
            // Landing on top
            if (player.velY > 0 && player.y + player.height - player.velY <= plat.y + 10) {
                player.grounded = true;
                player.velY = 0;
                player.y = plat.y - player.height;
            }
            // Hitting head on bottom
            else if (player.velY < 0 && player.y - player.velY >= plat.y + plat.height) {
                 player.velY = 0;
                 player.y = plat.y + plat.height;
            }
            // Side collisions
            else if(player.velX > 0 && player.x + player.width - player.velX <= plat.x + 10) {
                 player.x = plat.x - player.width;
                 player.velX = 0;
            }
            else if(player.velX < 0 && player.x - player.velX >= plat.x + plat.width - 10) {
                 player.x = plat.x + plat.width;
                 player.velX = 0;
            }
        }
    }

    // Entity Updates
    enemies.forEach(e => e.update());

    // Enemy Collision
    enemies.forEach(enemy => {
        if (!enemy.markedForDeletion && checkCollision(player, enemy)) {
            enemy.markedForDeletion = true;
            score += 100;
        }
    });
    enemies = enemies.filter(e => !e.markedForDeletion);
    
    // Win Condition
    if(checkCollision(player, goal)) {
        currentState = STATE.WIN;
        score += 1000;
    }

    // --- SMOOTH CAMERA LOGIC ---
    // 1. Target Center (X)
    let targetX = player.x - (GAME_WIDTH / 2) + (player.width / 2);
    if(targetX < 0) targetX = 0; // Clamp left boundary

    // 2. Target Center (Y) - Lookahead vertical camera
    // We offset by 20% height so player isn't dead center (better for platformers to see what's above/below)
    // IMPORTANT: Clamping Y so we don't show too much black void below ground
    let targetY = player.y - (GAME_HEIGHT * 0.6); 
    let maxCameraY = (GAME_HEIGHT - 40) - (GAME_HEIGHT * 0.9); // Don't scroll past ground too much
    
    // Smooth Lerp (0.1 factor)
    camera.x += (targetX - camera.x) * 0.1;
    camera.y += (targetY - camera.y) * 0.1;
}

function drawOverlay(title, subtitle) {
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    ctx.fillStyle = "#FFC107";
    ctx.textAlign = "center";
    ctx.font = "bold 40px 'Segoe UI', Arial";
    ctx.fillText(title, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
    
    ctx.fillStyle = "#FFF";
    ctx.font = "18px 'Segoe UI', Arial";
    ctx.fillText(subtitle, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
    ctx.textAlign = "left";
}

function draw() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.START) {
        drawOverlay("ADVENTURE WITH KOKO", "Tap Jump (â–²) to Start");
        return;
    }

    // Draw World
    platforms.forEach(p => p.draw(camera.x, camera.y));
    goal.draw(camera.x, camera.y);
    enemies.forEach(e => e.draw(camera.x, camera.y));
    player.draw(camera.x, camera.y);

    // Draw HUD
    ctx.fillStyle = "#FFF";
    ctx.font = "bold 24px 'Press Start 2P', monospace";
    ctx.shadowColor = "black";
    ctx.shadowBlur = 4;
    ctx.fillText("SCORE: " + score, 20, 50);
    ctx.shadowBlur = 0; // Reset

    if (currentState === STATE.GAMEOVER) {
        drawOverlay("GAME OVER", "Tap Jump (â–²) to Restart");
    } else if (currentState === STATE.WIN) {
        drawOverlay("YOU WIN", `Final Score: ${score} - Tap Jump (â–²) to Restart`);
    }
}

initGame();

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

</script>
</body>
</html>